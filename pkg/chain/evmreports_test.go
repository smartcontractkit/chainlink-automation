package chain

import (
	"math/rand"
	"testing"

	ktypes "github.com/smartcontractkit/ocr2keepers/pkg/types"
	"github.com/stretchr/testify/assert"
)

func TestNewEVMEncoder(t *testing.T) {
	enc := NewEVMReportEncoder()
	assert.NotNil(t, enc)
}

func TestEncodeReport(t *testing.T) {
	t.Run("Success", func(t *testing.T) {
		input := []ktypes.UpkeepResult{
			{Key: ktypes.UpkeepKey([]byte("1|1")), PerformData: []byte("hello")},
		}

		encoder := &evmReportEncoder{}
		b, err := encoder.EncodeReport(input)

		expected := []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}

		assert.NoError(t, err)
		assert.Equal(t, expected, b)
	})

	t.Run("Key Parse Error", func(t *testing.T) {
		input := []ktypes.UpkeepResult{
			{Key: ktypes.UpkeepKey([]byte("1")), PerformData: []byte("hello")},
		}

		encoder := &evmReportEncoder{}
		b, err := encoder.EncodeReport(input)

		assert.ErrorIs(t, err, ErrUpkeepKeyNotParsable)
		assert.Equal(t, []byte(nil), b)
	})
}

func BenchmarkEncodeReport(b *testing.B) {
	key1 := ktypes.UpkeepKey([]byte("1239487928374|187689279234987"))
	key2 := ktypes.UpkeepKey([]byte("1239487928374|187689279234989"))
	key3 := ktypes.UpkeepKey([]byte("1239487928375|187689279234987"))

	noData := []byte{}
	smallData := make([]byte, 12)
	largeData := make([]byte, 128)

	rand.Read(smallData)
	rand.Read(largeData)

	encoder := NewEVMReportEncoder()
	tests := []struct {
		Name string
		Data []ktypes.UpkeepResult
	}{
		{Name: "No Perform Data", Data: []ktypes.UpkeepResult{{Key: key1, PerformData: noData}}},
		{Name: "Small Perform Data", Data: []ktypes.UpkeepResult{{Key: key1, PerformData: smallData}}},
		{Name: "Large Perform Data", Data: []ktypes.UpkeepResult{{Key: key1, PerformData: largeData}}},
		{Name: "Multiple Performs", Data: []ktypes.UpkeepResult{{Key: key1, PerformData: smallData}, {Key: key2, PerformData: largeData}, {Key: key3, PerformData: noData}}},
	}

	for _, test := range tests {
		b.Run(test.Name, func(b *testing.B) {
			for n := 0; n < b.N; n++ {
				b.StartTimer()
				_, err := encoder.EncodeReport(test.Data)
				b.StopTimer()

				if err != nil {
					b.FailNow()
				}
			}
		})
	}
}
